# -*- coding: utf-8 -*-
"""timestamp_extractor.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zF_9j1PDBstdTdzxl8OaitIvFKUPu9_k
"""

"""
Instructions:
1. Replace the `summary_text` variable with your processed summary text.
2. Replace the `content_text` variable with your processed content text.
3. Run the script to execute the entire process using the provided text.
4. Summary and content text must be fed in exactly as shown in the example with
  hyphens before bullet points and timestamps in the same syntax shown in the example.

example:
from timestamp_extractor import process_summary

summary_text ='''
- Bullet point 1
- Bullet point 2
- Bullet point 3
'''

content_text ='''
[00:00:00] Line 1
[00:00:10] Line 2
[00:00:20] Line 3
'''

process_summary(summary_text, content_text)
_______________________________________________________________________________

expected output:
13
46
133
"""

import re
import nltk
import numpy as np
from sentence_transformers import SentenceTransformer

def process_summary(summary_text, content_text):
    # Preprocess the content text to extract lines and timestamps
    lines_with_timestamps = content_text.strip().split('\n')

    # Preprocess the summary text to extract bullet points
    bullet_points = [line.strip() for line in summary_text.split('\n') if line.strip()]

    # Initialize the Sentence Transformer model
    model = SentenceTransformer('all-MiniLM-L6-v2')

    # Compute embeddings for bullet points and lines
    bullet_point_embeddings = model.encode(bullet_points)
    line_embeddings = model.encode(lines_with_timestamps)

    # Function to convert timestamp to seconds
    def timestamp_to_seconds(timestamp):
        hours, minutes, seconds = map(int, timestamp.strip('[]').split(':'))
        total_seconds = hours * 3600 + minutes * 60 + seconds
        return total_seconds

    # List to store the seconds
    results = []

    # Iterate over all bullet points and find the closest match
    for bullet_point_embedding in bullet_point_embeddings:
        closest_match_index = None
        max_similarity = -1

        # Iterate over neighboring lines using a sliding window
        for i in range(len(line_embeddings) - 1):
            concatenated_lines = lines_with_timestamps[i] + " " + lines_with_timestamps[i + 1]
            concatenated_embedding = model.encode(concatenated_lines)
            similarity = np.dot(bullet_point_embedding, concatenated_embedding) / (
                        np.linalg.norm(bullet_point_embedding) * np.linalg.norm(concatenated_embedding))

            # Update the closest match if similarity is higher
            if similarity > max_similarity:
                max_similarity = similarity
                closest_match_index = i

        # Convert timestamp to seconds for the closest match
        if closest_match_index is not None:
            timestamp = lines_with_timestamps[closest_match_index].split(']')[0] + ']'
            seconds = timestamp_to_seconds(timestamp)
            results.append(seconds)
        else:
            results.append(float('inf'))  # Use infinity for unmatched bullet points to handle later

    seconds_list = results

    return seconds_list
